name: "Continuous Integration Continuous Delivery"

on:
  push:
    tags:
       - "v*"

env:
    RELEASE_VERSION: ${{ github.ref_name }}

jobs:
  build:
    runs-on: windows-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v3

      # Install the .NET Core workload
      - name: Dotnet setup
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: '8.0.x'
  
      # Add  MsBuild to the PATH: https://github.com/microsoft/setup-msbuild
      - name: Setup MSBuild.exe
        uses: microsoft/setup-msbuild@v1.1

      - name: Update manifest version
        run: |
          $manifest.Package.Identity.Version = "${{ env.RELEASE_VERSION }}"
          $manifest.Package.Identity.Name = "CutterManagementSystem"
          $manifest.Package.Identity.Publisher = "CN=Malachy Okwute"
          $manifest.Package.Properties.DisplayName = "CutterManagementSystem"
          $manifest.Package.Applications.Application.VisualElements.DisplayName = "CutterManagementSystem"
          $manifest.save("./CutterManagementSystem-${{ env.RELEASE_VERSION }}")

      # Decode the Base64 encoded Pfx
      - name: Decode the Pfx
        run: |
          $pfx_cert_byte = [System.Convert]::FromBase64String("${{ secrets.Base64_Encoded_Pfx }}")
          $currentDirectory = Get-Location
          $certificatePath = Join-Path -Path $currentDirectory -ChildPath ./CutterManagement.UI.Desktop -AdditionalChildPath GitHubActionsDemo.pfx
          [IO.File]::WriteAllBytes("$certificatePath", $pfx_cert_byte)
        if: matrix.ChannelName != 'Prod_Store'

      # Restore the application
      - name:  Restore the Wpf application to populate the obj folder
        run: msbuild CutterManagementSystem.sln /t:Restore /p:Configuration=Release /p:RuntimeIdentifier=win-x64

        # Build the Windows Application Packaging project
      - name: Build the Windows Application 
        run: msbuild CutterManagementSystem.sln /p:Platform=x64 /p:Configuration=Release /p:UapAppxPackageBuildMode=SideloadOnly /p:AppxBundle=Never /p:PackageCertificateKeyFile=GitHubActionsDemo.pfx /p:PackageCertificatePassword=${{ secrets.Pfx_Key }}
        if: matrix.ChannelName != 'Prod_Store'

        # Remove the .pfx
      - name: Remove the .pfx
        run: Remove-Item -path CutterManagement.UI.Desktop\GitHubActionsDemo.pfx
        if: matrix.ChannelName != 'Prod_Store'

      # Archive the package
      - name: Create archive
        run: Compress-Archive -Path CutterManagementSystem-${{ env.RELEASE_VERSION }} -DestinationPath CutterManagementSystem-$env:RELEASE_VERSION.zip

      # Create the release:  https://github.com/actions/create-release
      - name: Create release
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # This token is provided by Actions, you do not need to create your own token
        with:
          tag_name: ${{ github.ref}}.Release.win-x64
          release_name:  ${{ github.ref}}.Release.win-x64
          draft: false
          prerelease: false

       # Upload release asset:   https://github.com/actions/upload-release-asset
      - name: Update release asset
        id: upload-release-asset
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}  # This pulls from the CREATE RELEASE step above, referencing it's ID to get its outputs object, which include a `upload_url`. See this blog post for more info: https://jasonet.co/posts/new-features-of-github-actions/#passing-data-to-future-steps
          asset_path: CutterManagement.UI.Desktop\CutterManagementSystem-$env:RELEASE_VERSION.zip
          asset_name: CutterManagementSystem-$env:RELEASE_VERSION.zip
          asset_content_type: application/zip